<!DOCTYPE html>
<html>
<!-- Head -->
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>几种求平方根的算法 | lazzzis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="SICP 的第一章主要讲述了对过程的抽象。因此在这一章中以 Scheme 为例对函数操作讲了很大一部分。其中经常出现的一个例子就是求平方根的算法。
在以前，对于求平方根，我一般会首先考虑标准库，其次二分法。而在 SICP 中没有出现二分法，但其采用的几种算法的基本思路是与二分法类似的

先试验一个数，如果满意，返回这个数；否则，在猜测的数字上进一步优化，得到一个更接近结果的数字，继续试验

以下是">
<meta property="og:type" content="website">
<meta property="og:title" content="几种求平方根的算法">
<meta property="og:url" content="http://lazzzis.github.io/hexo-theme-mls/2016/11/23/sqrt-algorithms-in-sicp/index.html">
<meta property="og:site_name" content="lazzzis">
<meta property="og:description" content="SICP 的第一章主要讲述了对过程的抽象。因此在这一章中以 Scheme 为例对函数操作讲了很大一部分。其中经常出现的一个例子就是求平方根的算法。
在以前，对于求平方根，我一般会首先考虑标准库，其次二分法。而在 SICP 中没有出现二分法，但其采用的几种算法的基本思路是与二分法类似的

先试验一个数，如果满意，返回这个数；否则，在猜测的数字上进一步优化，得到一个更接近结果的数字，继续试验

以下是">
<meta property="og:image" content="https://s14.postimg.org/mwo681tkx/sqrt.png">
<meta property="og:updated_time" content="2016-12-13T15:12:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="几种求平方根的算法">
<meta name="twitter:description" content="SICP 的第一章主要讲述了对过程的抽象。因此在这一章中以 Scheme 为例对函数操作讲了很大一部分。其中经常出现的一个例子就是求平方根的算法。
在以前，对于求平方根，我一般会首先考虑标准库，其次二分法。而在 SICP 中没有出现二分法，但其采用的几种算法的基本思路是与二分法类似的

先试验一个数，如果满意，返回这个数；否则，在猜测的数字上进一步优化，得到一个更接近结果的数字，继续试验

以下是">
<meta name="twitter:creator" content="@lazzzis">
<link rel="publisher" href="https://plus.google.com/114550357749490779368">
  
    <link rel="alternative" href="/atom.xml" title="lazzzis" type="application/atom+xml">
  
  
    <link rel="icon" href="https://s18.postimg.org/k7qcci1t5/s_icon.png">
  
  <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/css/materialize.min.css">

    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://opensource.keycdn.com/fontawesome/4.7.0/font-awesome.min.css" integrity="sha384-dNpIIXE8U05kAbPhy3G1cz+yZmTzA6CY8Vg/u2L9xRnHjJiAK76m2BIEaSEV+/aU" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.15/css/share.min.css">
    <style>
        .hljs-line-numbers {
            text-align: right;
            border-right: 1px solid #ccc;
            color: #999;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
    <!-- <link rel="stylesheet" href="/hexo-theme-mls/css/style.css" type="text/css"> -->
    <!-- <link rel="stylesheet" href="/hexo-theme-mls/css/code.css" type="text/css"> -->
    <link rel="stylesheet" href="/hexo-theme-mls/css/style.css?version=5-15-53-13" type="text/css">
    <link rel="stylesheet" href="/hexo-theme-mls/css/code.css?version=5-15-53-13" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>


<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><header>
    <div class="navbar-fixed">
        <nav class="blue darken-3 nav-extended">
            <div class="nav-wrapper">
                <a href="#" data-activates="mobile-demo" class="button-collapse"><i class="material-icons">menu</i></a>
                <ul id="nav-mobile" class="hide-on-med-and-down">
                    
                        <li><a href="/" class="nav-logo">lazzzis</a></li>
                    
                    
                    <li><a class="" href="/">Home</a></li>
                    
                    <li><a class="" href="/archives">Archives</a></li>
                    
                    <li><a class="" href="/links">Links</a></li>
                    
                    <li><a class="" href="/about">About</a></li>
                    
                </ul>
            </div>
        </nav>

    </div>
    <ul class="side-nav" id="mobile-demo">
        
        <li><a class="" href="/">Home</a></li>
        
        <li><a class="" href="/archives">Archives</a></li>
        
        <li><a class="" href="/links">Links</a></li>
        
        <li><a class="" href="/about">About</a></li>
        
    </ul>
    <!--You have to move ul out to make sure this work in mobile environment-->
</header>


<div class="container">
      <article class="article-full">

    <!-- Title -->
    <h2 class="blog-item-title">
        <a href="/hexo-theme-mls/2016/11/23/sqrt-algorithms-in-sicp/">
            几种求平方根的算法
        </a>
    </h2>

    <!-- Date and Author -->
    <p class="blog-item-meta">
        Published on 2016 Nov 23 22:32:19
        
    
        </br>
        Last Updated on 2016 Dec 13 23:12:29
        
    </p>


    <!-- Content -->
    <p>SICP 的第一章主要讲述了对过程的抽象。因此在这一章中以 Scheme 为例对函数操作讲了很大一部分。其中经常出现的一个例子就是<strong>求平方根</strong>的算法。</p>
<p>在以前，对于求平方根，我一般会首先考虑标准库，其次二分法。而在 SICP 中没有出现二分法，但其采用的几种算法的基本思路是与二分法类似的</p>
<blockquote>
<p>先试验一个数，如果满意，返回这个数；否则，在猜测的数字上进一步优化，得到一个更接近结果的数字，继续试验</p>
</blockquote>
<p>以下是我对这几种算法的简要描述和比较（源码参考于 SICP 的 Scheme 代码。我在此基础上用 Python 改写）</p>
<h1 id="newtons-method-牛顿法">Newton’s Method / 牛顿法</h1><h2 id="基本方法">基本方法</h2><p>其关键的地方在于如何改进测试数。对于求 x 的平方根，即 sqrt(x)，如果测试数为 guess 且不符合要求，那么该如何得到一个更好的数。牛顿法认为，对于下一个数 next_guess，可以使 <code>next_guess = (guess + x / guess) / 2</code>。</p>
<p>我刚开始很好奇：为什么 next_guess 可行，因为我怀疑 x / guess 会不会和 guess 一样都小于或大于 sqrt(x)？如果是的话，那么 next_guess 岂不是可能比 guess 更不接近答案？</p>
<p>书中没有讲述，所以我试着证明了一下，发现这是不会的: 因为 <code>guess * (x / guess) = x</code> 是一定的，如果 <code>guess &lt; sqrt(x)</code>, 且 <code>(x / guess) &lt; sqrt(x)</code>, 那么 <code>guess * (x / guess) &lt; sqrt(x) * sqrt(x) = x</code>。这样的话，与已知不符，所以 guess 与 (x / guess) 必然居于 sqrt(x) 的两侧。</p>
<p>那怎么保证每次结果都会更接近呢？书中没有讲述，所以我还是试着自己证明了。如图，假设第一次猜测结果为 g1, 对应第二次猜测结果为 <code>g2 = (g1 + x / g1) / 2</code> 。那么接下来就是证明在图中 x / g2 会小于 x / g1。通过反证法，如果 g2 和 x / g2 都大于 g1 和 x / g1，那么 <code>g2 * (x / g2) &gt; g1 * (x / g1) = x</code>, 这与 <code>g2 * (x / g2) = x</code> 矛盾。由此可见，每一次猜测都会比上一次猜测更加靠近结果。</p>
<p><img src="https://s14.postimg.org/mwo681tkx/sqrt.png" alt="sqrt"><span class="image-caption">sqrt</span></p>
<p>以下是用Python实现的代码，其中 count 函数是用来通过计算 good_enough 的运行次数，来得到实际的运行次数。</p>
<pre><code class="python">def count(f):
    cnt = 0
    def _count(*args, **kwargs):
        nonlocal cnt
        cnt = cnt + 1
        print(cnt, *args, **kwargs)
        return f(*args)
    return _count

def newton_sqrt(x):

    tolerance = 0.0001 # 控制结果的精度

    def newton_sqrt_iter(guess):
        if (good_enough(guess)):
            return guess
        else:
            return newton_sqrt_iter(improve(guess))

    def square(x):
        return x * x

    @count
    def good_enough(guess):
        return abs(square(guess) - x) &lt; tolerance

    def improve(guess):
        return (guess + x / guess) / 2

    return newton_sqrt_iter(1)

print(newton_sqrt(37451))
</code></pre>
<p>算法时间复杂度为 <em>O(logN)</em> 。</p>
<h2 id="改进">改进</h2><p>主要的问题出现在计算较小的数字时，比如<code>newton_sqrt(1e-20)</code>时会返回 <code>0.0078125</code>。其中一种比较直接的解决方法就是提高对 <code>tolerance</code> 的限制，比如将其设为 <code>1e-20</code>。除此之外，还有一种提高精度的方法是对 good_enough 函数进行改进: 当连续两次测试数差值小于 tolerance 时，即认为这个测试数足够得好。所以更改代码为:</p>
<pre><code class="python">def newton_sqrt(x):

    tolerance = 0.0001 # 控制结果的精度

    def newton_sqrt_iter(guess):
        next_guess = improve(guess)
        if (good_enough(guess, next_guess)):
            return next_guess
        else:
            return newton_sqrt_iter(next_guess)

    def square(x):
        return x * x

    def good_enough(guess, next_guess):
        return abs(guess - next_guess) &lt; tolerance

    def improve(guess):
        return (guess + x / guess) / 2

    return newton_sqrt_iter(1)
</code></pre>
<p>注意在 newton_sqrt_iter 中返回的是 next_guess 而不是 guess。虽然返回 guess 也可行，但明显 next_guess 更适合，因为 next_guess 已经求出来，而且比 guess 更精确，那为什么不返回 next_guess 呢?</p>
<p>至于这样修改为什么可行，因为能力问题，我暂时并没有证明出来。但就实现来说，这样修改确实能提高结果准确度。</p>
<h1 id="fixed-point-不动点">Fixed Point / 不动点</h1><h2 id="基本方法">基本方法</h2><blockquote>
<p>如果说 x 是函数 f 的不动点，那么 x 满足等式 f(x) = x</p>
</blockquote>
<p>对于求不动点的方法，可以采用如下方法：任意给定一个数 x0，进行运算 <code>f(x0), f(f(x0)), f(f(f(x0))), f(f(f(f(x0)))) ...</code> 直到连续两次的值足够小之时，那么这个值即可看作不动点。</p>
<p>而借助不动点，可以求得平方根。假如求 x 的平方根，那么可以定义函数 f(y) = x / y。求得不动点 y0 满足 f(y0) = x / y0 = y0, 即<code>x = y0^2</code>，即求得了 x 的平方根。</p>
<p>代码实现与上一种有类似之处，同样是先测试一个数，然后不断改进，直至满足精度要求。</p>
<pre><code class="python">def fixed_point(f, guess):

    tolerance = 0.001

    def fixed_point_try(guess):
        next_guess = f(guess)
        if (good_enough(guess, next_guess)):
            return next_guess
        else:
            return fixed_point_try(next_guess)

    def good_enough(guess, next_guess):
        return abs(guess - next_guess) &lt; tolerance

    return fixed_point_try(guess)

def sqrt(x):
    return fixed_point(lambda y : x / y, 1.0)
</code></pre>
<p>其中 对于 f(y) = x / y，我采用了相对简洁的 lambda 表达式。</p>
<h2 id="改进">改进</h2><p>另外这个代码其实是<strong>有问题</strong>的，因为我第一次猜测的数字是 1.0。假如我求 sqrt(4), 那么 next_guess 一直会循环于 <code>4 1 4 1 4...</code>。一种解决方法是改变数字，但即使改变数字，仍会发现在求解一些较大的数时，比如 131313111 时，python 会显示 <code>RecursionError: maximum recursion depth exceeded in comparison</code>。而在 SICP 中则给出了另一种方法，是对传入在 sqrt 中对传入 fixed_point 的第一个参数，即自己设定的函数做一点小变化。将 <code>y = x / y</code> 变为 <code>y = 0.5 * (y + x / y)</code>。两个等式实际上是等价的，但用了后面这个式子可以减少 fixed_point_try 所需递归次数。SICP 中称为 <code>average damping</code>。所以修改部分代码为:</p>
<pre><code class="python">def average_damp(f):
    return lambda x: 0.5 * (x + f(x))

def sqrt(x):
    return fixed_point(average_damp(lambda y : x / y), 1.0)
</code></pre>
<p>至于为什么这样可行，书中没有提到，google 到的资料也并不多，但可知的是，average_damp 并不能加快所有函数求解不动点的速度，比如求解 y = x / 2 的不动点，用原函数会比用average_damp处理过的函数求不动点的速度更快。</p>
<h1 id="newtons-method-牛顿法更进一步">Newton’s Method / 牛顿法（更进一步）</h1><p>刚开始提到的牛顿法，其实属于牛顿法的一个特例。根据 SICP 提供的内容，我把它理解为:</p>
<blockquote>
<p>如果 g(x) 可微分，且 f(x) = x - g(x) / Dg(x), 那么 g(x) = 0 的解即为 f(x) 的不动点。</p>
</blockquote>
<p>其中 <em>D</em> g(x) 表示 g(x) 的导函数。</p>
<p>那么求 sqrt(x) 可以等价为求 g(y) = y^2 - x 的零点，又可等价为求 f(y) 的不动点，此时就又可以使用上一个方法中求不动点的函数。</p>
<p>对于表示 <em>D</em> g(x) 可以参考导函数的定义: <em>D</em> g(x) = (g(x + dx) + g(x)) / dx。只要 dx 足够小，那么求出的值也会足够精确。因此可以写出讲 g(x) 转换为 f(x) 的代码:</p>
<pre><code class="python">def deriv(f):
    return lambda x: (f(x + dx) - f(x)) / dx

def newton_transform(g):
    return lambda x: x - g(x) / deriv(g)(x)
</code></pre>
<p>在此基础上修改 sqrt 函数即可（与上文重复的部分用 pass 代替):</p>
<pre><code class="python">def fixed_point(f, guess):
    pass

def deriv(f):
    dx = 0.00001
    pass

def newton_transform(g):
    pass

def sqrt(x):
    return fixed_point(newton_transform(lambda y: x - y * y), 1.0)
</code></pre>
<h1 id="比较">比较</h1><p>我随意选了一些数据做测试，其中括号中为 good_enough 的调用次数</p>
<table>
<thead>
<tr>
<th>测试数据</th>
<th>牛顿法</th>
<th>不动点</th>
<th>牛顿法（进一步）</th>
<th>math.sqrt</th>
</tr>
</thead>
<tbody>
<tr>
<td>4e-10</td>
<td>(14) 6.320421028899002e-05</td>
<td>(14) 6.320421028899002e-05</td>
<td>(14) 6.793792409042473e-05</td>
<td>2e-5</td>
</tr>
<tr>
<td>4e10</td>
<td>(23) 200000.0</td>
<td>(23) 200000.0</td>
<td>(22) 200000.0</td>
<td>200000.0</td>
</tr>
<tr>
<td>17</td>
<td>(6) 4.123105625617805</td>
<td>(6) 4.123105625617805</td>
<td>(6) 4.123105625619134</td>
<td>4.123105625617661</td>
</tr>
<tr>
<td>177</td>
<td>(8) 13.30413469565007</td>
<td>(8) 13.30413469565007</td>
<td>(8) 13.304134695650115</td>
<td>13.30413469565007</td>
</tr>
</tbody>
</table>
<p>可以发现：大体来说其实也差不了太多。其中，进一步的牛顿法受限于 dx 的精读不够，如果将 dx 调小至 0.0000001, 那么结果则与前两者差不多了。</p>
<p>另外，求平方根的方法肯定不只这么几种，必然有更多方法。这些方法在一定程度上能拓展学习者的思路。<del>但一般情况下，大部分人还是直接调用标准库吧。</del></p>
<h1 id="参考">参考</h1><ol>
<li><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="external">SICP</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9" target="_blank" rel="external">Wikipedia 不动点</a></li>
<li><a href="http://stackoverflow.com/questions/3860929/why-does-average-damping-magically-speed-up-the-convergence-of-fixed-point-calcu" target="_blank" rel="external">Why does average damping magically speed up the convergence of fixed-point calculators?</a></li>
</ol>


    <hr/>

    
        <div class="social-share" data-disabled="weibo,qzone,qq,tencent,douban,linkedin,diandian"></div>
    

    <div class="blog-post">

    <!--[...]-->
    
    <!-- Comments -->
</div>

    <!-- Tags and Categories links -->


</article>


</div>


<footer class="grey darken-3">
    <div class="footer-link">
        
        <a href="https://github.com/lazzzis" target="_blank"><i class="fa fa-github fa-2x" aria-hidden="true"></i></a>
        
        
        <a href="https://twitter.com/lazzzis" target="_blank"><i class="fa fa-twitter fa-2x" aria-hidden="true"></i></a>
        
        
        <a href="https://www.instagram.com/lazzzis" target="_blank"><i class="fa fa-instagram fa-2x" aria-hidden="true"></i></a>
        
        
        
        <a href="https://plus.google.com/114550357749490779368" target="_blank"><i class="fa fa-google-plus-official fa-2x" aria-hidden="true"></i>
        
        
        <a href="http://music.163.com/#/user/home?id=30744948" target="_blank"><i class="fa fa-music fa-2x" aria-hidden="true"></i></a>
        
        
          <a href="/atom.xml" target="_blank" title="rss_feed"><i class="fa fa-rss fa-2x" aria-hidden="true"></i></a>
        
    </div>
    <div class="footer-ps">
        <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> -
            &copy; 2017 <a
                    
                    href="https://github.com/lazzzis" target="_blank"
                    
            > lazzzis</a> - Theme <a href="https://github.com/lazzzis/hexo-theme-mls" target="_blank">MLS</a>
        </p>
    </div>
</footer>

<!--Import jQuery before materialize.js-->
<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<!-- Compiled and minified JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.8/js/materialize.min.js"></script>

<script src="//cdn.bootcss.com/highlight.js/9.6.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.15/js/social-share.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fitvids/1.1.0/jquery.fitvids.min.js"></script>
<script src="/hexo-theme-mls/js/addition.js" type="text/javascript"></script>
<script src="/hexo-theme-mls/js/zooming.js" type="text/javascript"></script>
<!-- Disqus Comments -->



<script>
    // https://github.com/srobbin/jquery-backstretch
    $.backstretch("/hexo-theme-mls/css/images/background.jpg?version=5-15-53-13");

    
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-87274131-1', 'auto');
        ga('send', 'pageview');
    

</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</body>

</html>
