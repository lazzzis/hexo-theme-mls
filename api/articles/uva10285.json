{"title":"UVa10285 - Longest Run on a Snowboard","slug":"uva10285","date":"2015-11-29T02:22:47.000Z","updated":"2016-11-08T14:42:44.000Z","comments":true,"path":"api/articles/uva10285.json","excerpt":"<h2 id=\"思路\">思路</h2><p>假设从( x, y )出发，并且从( x, y )出发所能走的最长路为 d[x][y]，那么设想如果( x  - 1, y )的值（即题目所给的高度）要小于(x，y)，那么d[x-1][y] + 1 有可能就是我们所要求的d[x][y]，因为这条路是单向的，只可能从较小的(x-1， y)走向(x，y)。如果考虑四个方向，用(x’， y’)表示(x ， y)上下左右四个方向，那么d[x][y] = max(d[x’][y’]) + 1，且 (x’, y’)上的值要小于(x, y)。那么从这个方程可以看出这实际上可以采用 DFS 加上 dp 的做法，或者称之为记忆化搜索。而 搜索 的终点则是某点(x, y)的四周都比他大，则返回 1。</p>\n<h2 id=\"代码\">代码</h2><pre><code class=\"cpp\">/*\n * AC @ Nov 26th 2015\n * Run Time : 0.003s\n */\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair&lt;int, int&gt; pr_int;\n\nint dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};\nconst int MAXN = 100 + 40;\nint height[MAXN][MAXN], d[MAXN][MAXN];\nstring name;\nint rows, cols;\n\nvoid read() {\n    cin &gt;&gt; name &gt;&gt; rows &gt;&gt; cols;\n    for (int i = 0; i &lt; rows; ++i) {\n        for (int j = 0; j &lt; cols; ++j) {\n            cin &gt;&gt; height[i][j];\n        }\n    }\n}\n\nint dp(int x, int y) {\n    if (d[x][y] != -1) {\n        return d[x][y];\n    }\n    int ans = 1;\n    for (int i = 0; i &lt; 4; ++ i) {\n        int nx = x + dir[i][0], ny = y + dir[i][1];\n        //cout &lt;&lt; nx &lt;&lt; &quot; : &quot; &lt;&lt; ny  &lt;&lt; &quot; &quot; &lt;&lt; height[x][y] &lt;&lt; &quot; &quot; &lt;&lt; height[nx][ny] &lt;&lt; endl;\n        if (nx &gt;=0 &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;=0 &amp;&amp; ny &lt; cols &amp;&amp; height[x][y] &gt; height[nx][ny]) {\n            ans = max(dp(nx, ny) + 1, ans);\n        }\n    }\n    //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n    return d[x][y] = ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while(T --) {\n        read();\n        int ans = 1;\n        memset(d, -1, sizeof(d));\n        for (int i = 0; i &lt; rows; ++ i) {\n            for (int j = 0; j &lt; cols; ++ j) {\n                ans = max(ans, dp(i, j));\n            }\n        }\n        cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>","content":"<h2 id=\"思路\">思路</h2><p>假设从( x, y )出发，并且从( x, y )出发所能走的最长路为 d[x][y]，那么设想如果( x  - 1, y )的值（即题目所给的高度）要小于(x，y)，那么d[x-1][y] + 1 有可能就是我们所要求的d[x][y]，因为这条路是单向的，只可能从较小的(x-1， y)走向(x，y)。如果考虑四个方向，用(x’， y’)表示(x ， y)上下左右四个方向，那么d[x][y] = max(d[x’][y’]) + 1，且 (x’, y’)上的值要小于(x, y)。那么从这个方程可以看出这实际上可以采用 DFS 加上 dp 的做法，或者称之为记忆化搜索。而 搜索 的终点则是某点(x, y)的四周都比他大，则返回 1。</p>\n<h2 id=\"代码\">代码</h2><pre><code class=\"cpp\">/*\n * AC @ Nov 26th 2015\n * Run Time : 0.003s\n */\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair&lt;int, int&gt; pr_int;\n\nint dir[4][2] = {0, 1, 0, -1, 1, 0, -1, 0};\nconst int MAXN = 100 + 40;\nint height[MAXN][MAXN], d[MAXN][MAXN];\nstring name;\nint rows, cols;\n\nvoid read() {\n    cin &gt;&gt; name &gt;&gt; rows &gt;&gt; cols;\n    for (int i = 0; i &lt; rows; ++i) {\n        for (int j = 0; j &lt; cols; ++j) {\n            cin &gt;&gt; height[i][j];\n        }\n    }\n}\n\nint dp(int x, int y) {\n    if (d[x][y] != -1) {\n        return d[x][y];\n    }\n    int ans = 1;\n    for (int i = 0; i &lt; 4; ++ i) {\n        int nx = x + dir[i][0], ny = y + dir[i][1];\n        //cout &lt;&lt; nx &lt;&lt; &quot; : &quot; &lt;&lt; ny  &lt;&lt; &quot; &quot; &lt;&lt; height[x][y] &lt;&lt; &quot; &quot; &lt;&lt; height[nx][ny] &lt;&lt; endl;\n        if (nx &gt;=0 &amp;&amp; nx &lt; rows &amp;&amp; ny &gt;=0 &amp;&amp; ny &lt; cols &amp;&amp; height[x][y] &gt; height[nx][ny]) {\n            ans = max(dp(nx, ny) + 1, ans);\n        }\n    }\n    //cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n    return d[x][y] = ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int T;\n    cin &gt;&gt; T;\n    while(T --) {\n        read();\n        int ans = 1;\n        memset(d, -1, sizeof(d));\n        for (int i = 0; i &lt; rows; ++ i) {\n            for (int j = 0; j &lt; cols; ++ j) {\n                ans = max(ans, dp(i, j));\n            }\n        }\n        cout &lt;&lt; name &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n","categories":[{"name":"ACM","slug":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","path":"api/tags/ACM.json"},{"name":"UVaOJ","slug":"UVaOJ","path":"api/tags/UVaOJ.json"}]}