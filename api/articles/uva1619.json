{"title":"UVa1619 - Feel Good","slug":"uva1619","date":"2015-12-22T11:32:46.000Z","updated":"2016-11-08T14:42:33.000Z","comments":true,"path":"api/articles/uva1619.json","excerpt":"<h1 id=\"思路\">思路</h1><p>明确题目所求 <span>$(a_l + a_{l+1} + \\dots + a_r) * min(a_l, a_{l + 2}, \\dots , a_r)$</span><!-- Has MathJax --> 。从公式可以看出，是由两部分组成，一部分是区间和, 另一部分是区间最小值。<br>想法一：受连续最大子序列和的影响，设想是否可以通过 $O(N)$ 的算法获得？但问题是，这个公式有两个部分，或者说，要同时控制两个变量，难度有点大。目前我没有想出什么对应的好办法。<br>想法二：对于两个部分，控制其中一个部分不变，让另一部分尽量大。例如对于  <span>$a_i$</span><!-- Has MathJax -->, 寻找区间 <span>$[l ,r]$</span><!-- Has MathJax -->, 其中  <span>$l &lt;= i &lt;= r$</span><!-- Has MathJax -->， 令<span>$a_i$</span><!-- Has MathJax -->在这个区间内为最小值，则只要区间最大化即可，也就是说，在这个区间内， <span>$a_i$</span><!-- Has MathJax -->是最小值，如果区间再扩大，则  <span>$a_i$</span><!-- Has MathJax --> 不再是这个区间的最小值。对于每一个  <span>$a_i$</span><!-- Has MathJax --> 如何确定区间呢？可以使用设置一个递增的单调队列，从序列的最左边开始，对每一个  <span>$a_i$</span><!-- Has MathJax -->, 寻找比它小的第一个数，此时能确定左边界，同样的，如果单调序列从右边开始，则可以确定右边界。</p>\n<p>需要特别注意的是, 对于我的代码， 在数据为:</p>\n<pre><code>5\n0 0 0 0 0\n</code></pre>","content":"<h1 id=\"思路\">思路</h1><p>明确题目所求 <span>$(a_l + a_{l+1} + \\dots + a_r) * min(a_l, a_{l + 2}, \\dots , a_r)$</span><!-- Has MathJax --> 。从公式可以看出，是由两部分组成，一部分是区间和, 另一部分是区间最小值。<br>想法一：受连续最大子序列和的影响，设想是否可以通过 $O(N)$ 的算法获得？但问题是，这个公式有两个部分，或者说，要同时控制两个变量，难度有点大。目前我没有想出什么对应的好办法。<br>想法二：对于两个部分，控制其中一个部分不变，让另一部分尽量大。例如对于  <span>$a_i$</span><!-- Has MathJax -->, 寻找区间 <span>$[l ,r]$</span><!-- Has MathJax -->, 其中  <span>$l &lt;= i &lt;= r$</span><!-- Has MathJax -->， 令<span>$a_i$</span><!-- Has MathJax -->在这个区间内为最小值，则只要区间最大化即可，也就是说，在这个区间内， <span>$a_i$</span><!-- Has MathJax -->是最小值，如果区间再扩大，则  <span>$a_i$</span><!-- Has MathJax --> 不再是这个区间的最小值。对于每一个  <span>$a_i$</span><!-- Has MathJax --> 如何确定区间呢？可以使用设置一个递增的单调队列，从序列的最左边开始，对每一个  <span>$a_i$</span><!-- Has MathJax -->, 寻找比它小的第一个数，此时能确定左边界，同样的，如果单调序列从右边开始，则可以确定右边界。</p>\n<p>需要特别注意的是, 对于我的代码， 在数据为:</p>\n<pre><code>5\n0 0 0 0 0\n</code></pre><p>时，需要特别判断一下。</p>\n<h1 id=\"代码\">代码</h1><pre><code class=\"cpp\">/**\n * Run Time : 139ms\n */\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair&lt;int, int&gt; pr_int;\n\nint N;\nvector&lt;LL&gt; v;\nconst int MAXN = 100000 + 50;\nint left_min[MAXN], right_min[MAXN];\n\nvoid read() {\n    v.clear();\n    for (int i = 0; i &lt; N; ++ i) {\n        LL t;\n        cin &gt;&gt; t;\n        v.push_back(t);\n    }\n}\n\nvoid work() {\n    stack&lt;pr_int&gt; st;\n\n    // left\n    st.push(make_pair(-1, -10e7));\n    for (int i = 0; i &lt; N; ++ i) {\n        while (st.top().second &gt;= v[i]) {\n            st.pop();\n        }\n        left_min[i] = st.top().first;\n        st.push(make_pair(i, v[i]));\n    }\n\n    // right\n    while(!st.empty()) {\n        st.pop();\n    }\n    st.push(make_pair(N, -10e7));\n    for (int i = N - 1; i &gt;= 0; -- i) {\n        while (st.top().second &gt;= v[i]) {\n            st.pop();\n        }\n        right_min[i] = st.top().first;\n        st.push(make_pair(i, v[i]));\n    }\n\n    vector&lt;LL&gt; sum;\n    sum.push_back(v[0]);\n    for (int i = 1; i &lt; N; ++ i) {\n        sum.push_back(v[i] + sum[i - 1]);\n    }\n    int lr, rr;\n    LL ans = 0;\n    for (int i = 0; i &lt; N; ++ i) {\n        //cout &lt;&lt; left_min[i] &lt;&lt; &quot; &quot; &lt;&lt; right_min[i] &lt;&lt; endl;\n        LL sumL = left_min[i] == -1 ? 0 : sum[left_min[i]];\n        if ( (sum[right_min[i] - 1] - sumL) * v[i] &gt; ans ) {\n            ans = (sum[right_min[i] - 1] - sumL) * v[i];\n            lr = left_min[i] + 1 + 1;\n            rr = right_min[i];\n        } else if ((sum[right_min[i] - 1] - sumL) * v[i] == ans &amp;&amp;\n         right_min[i] - left_min[i] &lt; rr - lr + 2 ) {\n            lr = left_min[i] + 2;\n            rr = right_min[i];\n        }\n    }\n    if (ans == 0) {\n        cout &lt;&lt; &quot;0\\n1 1&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; lr &lt;&lt; &quot; &quot; &lt;&lt; rr &lt;&lt; endl;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    int K = 0;\n    while(cin &gt;&gt; N) {\n        if (K) {\n            cout &lt;&lt; endl;\n        }\n        K = 1;\n        read();\n        work();\n    }\n    return 0;\n}\n</code></pre>\n","categories":[{"name":"ACM","slug":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","path":"api/tags/ACM.json"},{"name":"UVaOJ","slug":"UVaOJ","path":"api/tags/UVaOJ.json"}]}