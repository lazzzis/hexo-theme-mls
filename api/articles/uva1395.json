{"title":"UVa1395 - Slim Span","slug":"uva1395","date":"2016-01-25T06:05:41.000Z","updated":"2016-11-08T14:42:21.000Z","comments":true,"path":"api/articles/uva1395.json","excerpt":"<h1 id=\"思路\">思路</h1><p>首先有一点是可以确定的：对于任何一连通图，必有一生成树（简直废话）。<br>对于这一题，关键的问题是确定最大与最小。对于这种寻找两个相关变量的题，其实一般可以先试着确定一个，然后再去寻找另一个。<br>比如在这题中，可以迭代每一个边 L，同时把这条边 L 当做最小的边，用比它大的边去试着连同一幅图，知道找到边 R， 使得加上这条边 R 后刚好可以凑成一幅联通图。<br>因此，从上述思路可以看出，排序是必不可少了。所有排序是第一步。<br>排序好后进行遍历 L，建立 N （顶点数） 个并查集 S，每加入一条边就将该边的端点对应的并查集合并（前提是两个端点对应不同的并查集）。<br>直到刚好加入边 R 后，并查集只剩一个，且大小刚好与顶点数相等。此时对于 L 来说，R － L 极为其 “苗条度”。<br>因此对所有求得的“苗条度”求一个最小值即可。如果连一个“苗条度”都没有，那结果自然就是找不到合适的答案了。</p>\n<h1 id=\"代码\">代码</h1><pre><code class=\"cpp\">/*\n * Run Time : 0.033s\n */\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nstruct Node{\n    int first, second;\n    int len;\n};\n\nbool cmp(Node a, Node b) {\n    return a.len &lt; b.len;\n}\n\nconst int INF = 1000000;\nconst int MAXN = 100 + 50;\nint N, M;\nvector&lt;Node&gt; nodes;\nint size[MAXN], root[MAXN];\n\nvoid read() {\n    int a, b, k;\n    nodes.clear();\n    for (int i = 0; i &lt; M; ++ i) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;\n        Node n;\n        n.first = a; n.second = b; n.len = k;\n        nodes.push_back(n);\n    }\n}\n\nint ans;\n\nint Find(int n) {\n    if (root[n] == n) {\n        return n;\n    }\n    return root[n] = Find(root[n]);\n}\n\nvoid work() {\n    sort(nodes.begin(), nodes.end(), cmp);\n    ans = INF;\n    for (int i = 0, j; i &lt; M; ++ i) {\n        for (j = 1; j &lt;= N; ++ j) {\n            size[j] = 1;\n            root[j] = j;\n        }\n        for (j = i; j &lt; M; ++ j) {\n            int ra = Find(nodes[j].first);\n            int rb = Find(nodes[j].second);\n            if (ra != rb) {\n                root[rb] = ra;\n                size[ra] += size[rb];\n            }\n            if (size[Find(1)] == N) {\n                break;\n            }\n        }\n        if (size[Find(1)] == N) {\n            ans = min(nodes[j].len - nodes[i].len, ans);\n        } else if (size[Find(1)] &lt; N) {\n            break;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin &gt;&gt; N &gt;&gt; M &amp;&amp; (N + M)) {\n        read();\n        work();\n        cout &lt;&lt; (ans == INF ? -1 : ans) &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>","content":"<h1 id=\"思路\">思路</h1><p>首先有一点是可以确定的：对于任何一连通图，必有一生成树（简直废话）。<br>对于这一题，关键的问题是确定最大与最小。对于这种寻找两个相关变量的题，其实一般可以先试着确定一个，然后再去寻找另一个。<br>比如在这题中，可以迭代每一个边 L，同时把这条边 L 当做最小的边，用比它大的边去试着连同一幅图，知道找到边 R， 使得加上这条边 R 后刚好可以凑成一幅联通图。<br>因此，从上述思路可以看出，排序是必不可少了。所有排序是第一步。<br>排序好后进行遍历 L，建立 N （顶点数） 个并查集 S，每加入一条边就将该边的端点对应的并查集合并（前提是两个端点对应不同的并查集）。<br>直到刚好加入边 R 后，并查集只剩一个，且大小刚好与顶点数相等。此时对于 L 来说，R － L 极为其 “苗条度”。<br>因此对所有求得的“苗条度”求一个最小值即可。如果连一个“苗条度”都没有，那结果自然就是找不到合适的答案了。</p>\n<h1 id=\"代码\">代码</h1><pre><code class=\"cpp\">/*\n * Run Time : 0.033s\n */\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nstruct Node{\n    int first, second;\n    int len;\n};\n\nbool cmp(Node a, Node b) {\n    return a.len &lt; b.len;\n}\n\nconst int INF = 1000000;\nconst int MAXN = 100 + 50;\nint N, M;\nvector&lt;Node&gt; nodes;\nint size[MAXN], root[MAXN];\n\nvoid read() {\n    int a, b, k;\n    nodes.clear();\n    for (int i = 0; i &lt; M; ++ i) {\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;\n        Node n;\n        n.first = a; n.second = b; n.len = k;\n        nodes.push_back(n);\n    }\n}\n\nint ans;\n\nint Find(int n) {\n    if (root[n] == n) {\n        return n;\n    }\n    return root[n] = Find(root[n]);\n}\n\nvoid work() {\n    sort(nodes.begin(), nodes.end(), cmp);\n    ans = INF;\n    for (int i = 0, j; i &lt; M; ++ i) {\n        for (j = 1; j &lt;= N; ++ j) {\n            size[j] = 1;\n            root[j] = j;\n        }\n        for (j = i; j &lt; M; ++ j) {\n            int ra = Find(nodes[j].first);\n            int rb = Find(nodes[j].second);\n            if (ra != rb) {\n                root[rb] = ra;\n                size[ra] += size[rb];\n            }\n            if (size[Find(1)] == N) {\n                break;\n            }\n        }\n        if (size[Find(1)] == N) {\n            ans = min(nodes[j].len - nodes[i].len, ans);\n        } else if (size[Find(1)] &lt; N) {\n            break;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(cin &gt;&gt; N &gt;&gt; M &amp;&amp; (N + M)) {\n        read();\n        work();\n        cout &lt;&lt; (ans == INF ? -1 : ans) &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<h1 id=\"后记\">后记</h1><p>最近没怎么练习，在做这题时犯了一个低级错误。刚开始使用了一个 set （集合）代替并查集。当 set 大小为 N 时，即可计算“苗条度”<br>这种想法当然是<strong>错误</strong>的！！！很明贤，顶点数达到要求了，但并不一定代表图已经连通！</p>\n","categories":[{"name":"ACM","slug":"ACM","path":"api/categories/ACM.json"}],"tags":[{"name":"ACM","slug":"ACM","path":"api/tags/ACM.json"},{"name":"UVaOJ","slug":"UVaOJ","path":"api/tags/UVaOJ.json"}]}