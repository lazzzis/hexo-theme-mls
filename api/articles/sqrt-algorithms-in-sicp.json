{"title":"几种求平方根的算法","slug":"sqrt-algorithms-in-sicp","date":"2016-11-23T14:32:19.000Z","updated":"2016-12-13T15:12:29.000Z","comments":true,"path":"api/articles/sqrt-algorithms-in-sicp.json","excerpt":"<p>SICP 的第一章主要讲述了对过程的抽象。因此在这一章中以 Scheme 为例对函数操作讲了很大一部分。其中经常出现的一个例子就是<strong>求平方根</strong>的算法。</p>\n<p>在以前，对于求平方根，我一般会首先考虑标准库，其次二分法。而在 SICP 中没有出现二分法，但其采用的几种算法的基本思路是与二分法类似的</p>\n<blockquote>\n<p>先试验一个数，如果满意，返回这个数；否则，在猜测的数字上进一步优化，得到一个更接近结果的数字，继续试验</p>\n</blockquote>\n<p>以下是我对这几种算法的简要描述和比较（源码参考于 SICP 的 Scheme 代码。我在此基础上用 Python 改写）</p>","content":"<p>SICP 的第一章主要讲述了对过程的抽象。因此在这一章中以 Scheme 为例对函数操作讲了很大一部分。其中经常出现的一个例子就是<strong>求平方根</strong>的算法。</p>\n<p>在以前，对于求平方根，我一般会首先考虑标准库，其次二分法。而在 SICP 中没有出现二分法，但其采用的几种算法的基本思路是与二分法类似的</p>\n<blockquote>\n<p>先试验一个数，如果满意，返回这个数；否则，在猜测的数字上进一步优化，得到一个更接近结果的数字，继续试验</p>\n</blockquote>\n<p>以下是我对这几种算法的简要描述和比较（源码参考于 SICP 的 Scheme 代码。我在此基础上用 Python 改写）</p>\n<h1 id=\"newtons-method-牛顿法\">Newton’s Method / 牛顿法</h1><h2 id=\"基本方法\">基本方法</h2><p>其关键的地方在于如何改进测试数。对于求 x 的平方根，即 sqrt(x)，如果测试数为 guess 且不符合要求，那么该如何得到一个更好的数。牛顿法认为，对于下一个数 next_guess，可以使 <code>next_guess = (guess + x / guess) / 2</code>。</p>\n<p>我刚开始很好奇：为什么 next_guess 可行，因为我怀疑 x / guess 会不会和 guess 一样都小于或大于 sqrt(x)？如果是的话，那么 next_guess 岂不是可能比 guess 更不接近答案？</p>\n<p>书中没有讲述，所以我试着证明了一下，发现这是不会的: 因为 <code>guess * (x / guess) = x</code> 是一定的，如果 <code>guess &lt; sqrt(x)</code>, 且 <code>(x / guess) &lt; sqrt(x)</code>, 那么 <code>guess * (x / guess) &lt; sqrt(x) * sqrt(x) = x</code>。这样的话，与已知不符，所以 guess 与 (x / guess) 必然居于 sqrt(x) 的两侧。</p>\n<p>那怎么保证每次结果都会更接近呢？书中没有讲述，所以我还是试着自己证明了。如图，假设第一次猜测结果为 g1, 对应第二次猜测结果为 <code>g2 = (g1 + x / g1) / 2</code> 。那么接下来就是证明在图中 x / g2 会小于 x / g1。通过反证法，如果 g2 和 x / g2 都大于 g1 和 x / g1，那么 <code>g2 * (x / g2) &gt; g1 * (x / g1) = x</code>, 这与 <code>g2 * (x / g2) = x</code> 矛盾。由此可见，每一次猜测都会比上一次猜测更加靠近结果。</p>\n<p><img src=\"https://s14.postimg.org/mwo681tkx/sqrt.png\" alt=\"sqrt\"><span class=\"image-caption\">sqrt</span></p>\n<p>以下是用Python实现的代码，其中 count 函数是用来通过计算 good_enough 的运行次数，来得到实际的运行次数。</p>\n<pre><code class=\"python\">def count(f):\n    cnt = 0\n    def _count(*args, **kwargs):\n        nonlocal cnt\n        cnt = cnt + 1\n        print(cnt, *args, **kwargs)\n        return f(*args)\n    return _count\n\ndef newton_sqrt(x):\n\n    tolerance = 0.0001 # 控制结果的精度\n\n    def newton_sqrt_iter(guess):\n        if (good_enough(guess)):\n            return guess\n        else:\n            return newton_sqrt_iter(improve(guess))\n\n    def square(x):\n        return x * x\n\n    @count\n    def good_enough(guess):\n        return abs(square(guess) - x) &lt; tolerance\n\n    def improve(guess):\n        return (guess + x / guess) / 2\n\n    return newton_sqrt_iter(1)\n\nprint(newton_sqrt(37451))\n</code></pre>\n<p>算法时间复杂度为 <em>O(logN)</em> 。</p>\n<h2 id=\"改进\">改进</h2><p>主要的问题出现在计算较小的数字时，比如<code>newton_sqrt(1e-20)</code>时会返回 <code>0.0078125</code>。其中一种比较直接的解决方法就是提高对 <code>tolerance</code> 的限制，比如将其设为 <code>1e-20</code>。除此之外，还有一种提高精度的方法是对 good_enough 函数进行改进: 当连续两次测试数差值小于 tolerance 时，即认为这个测试数足够得好。所以更改代码为:</p>\n<pre><code class=\"python\">def newton_sqrt(x):\n\n    tolerance = 0.0001 # 控制结果的精度\n\n    def newton_sqrt_iter(guess):\n        next_guess = improve(guess)\n        if (good_enough(guess, next_guess)):\n            return next_guess\n        else:\n            return newton_sqrt_iter(next_guess)\n\n    def square(x):\n        return x * x\n\n    def good_enough(guess, next_guess):\n        return abs(guess - next_guess) &lt; tolerance\n\n    def improve(guess):\n        return (guess + x / guess) / 2\n\n    return newton_sqrt_iter(1)\n</code></pre>\n<p>注意在 newton_sqrt_iter 中返回的是 next_guess 而不是 guess。虽然返回 guess 也可行，但明显 next_guess 更适合，因为 next_guess 已经求出来，而且比 guess 更精确，那为什么不返回 next_guess 呢?</p>\n<p>至于这样修改为什么可行，因为能力问题，我暂时并没有证明出来。但就实现来说，这样修改确实能提高结果准确度。</p>\n<h1 id=\"fixed-point-不动点\">Fixed Point / 不动点</h1><h2 id=\"基本方法\">基本方法</h2><blockquote>\n<p>如果说 x 是函数 f 的不动点，那么 x 满足等式 f(x) = x</p>\n</blockquote>\n<p>对于求不动点的方法，可以采用如下方法：任意给定一个数 x0，进行运算 <code>f(x0), f(f(x0)), f(f(f(x0))), f(f(f(f(x0)))) ...</code> 直到连续两次的值足够小之时，那么这个值即可看作不动点。</p>\n<p>而借助不动点，可以求得平方根。假如求 x 的平方根，那么可以定义函数 f(y) = x / y。求得不动点 y0 满足 f(y0) = x / y0 = y0, 即<code>x = y0^2</code>，即求得了 x 的平方根。</p>\n<p>代码实现与上一种有类似之处，同样是先测试一个数，然后不断改进，直至满足精度要求。</p>\n<pre><code class=\"python\">def fixed_point(f, guess):\n\n    tolerance = 0.001\n\n    def fixed_point_try(guess):\n        next_guess = f(guess)\n        if (good_enough(guess, next_guess)):\n            return next_guess\n        else:\n            return fixed_point_try(next_guess)\n\n    def good_enough(guess, next_guess):\n        return abs(guess - next_guess) &lt; tolerance\n\n    return fixed_point_try(guess)\n\ndef sqrt(x):\n    return fixed_point(lambda y : x / y, 1.0)\n</code></pre>\n<p>其中 对于 f(y) = x / y，我采用了相对简洁的 lambda 表达式。</p>\n<h2 id=\"改进\">改进</h2><p>另外这个代码其实是<strong>有问题</strong>的，因为我第一次猜测的数字是 1.0。假如我求 sqrt(4), 那么 next_guess 一直会循环于 <code>4 1 4 1 4...</code>。一种解决方法是改变数字，但即使改变数字，仍会发现在求解一些较大的数时，比如 131313111 时，python 会显示 <code>RecursionError: maximum recursion depth exceeded in comparison</code>。而在 SICP 中则给出了另一种方法，是对传入在 sqrt 中对传入 fixed_point 的第一个参数，即自己设定的函数做一点小变化。将 <code>y = x / y</code> 变为 <code>y = 0.5 * (y + x / y)</code>。两个等式实际上是等价的，但用了后面这个式子可以减少 fixed_point_try 所需递归次数。SICP 中称为 <code>average damping</code>。所以修改部分代码为:</p>\n<pre><code class=\"python\">def average_damp(f):\n    return lambda x: 0.5 * (x + f(x))\n\ndef sqrt(x):\n    return fixed_point(average_damp(lambda y : x / y), 1.0)\n</code></pre>\n<p>至于为什么这样可行，书中没有提到，google 到的资料也并不多，但可知的是，average_damp 并不能加快所有函数求解不动点的速度，比如求解 y = x / 2 的不动点，用原函数会比用average_damp处理过的函数求不动点的速度更快。</p>\n<h1 id=\"newtons-method-牛顿法更进一步\">Newton’s Method / 牛顿法（更进一步）</h1><p>刚开始提到的牛顿法，其实属于牛顿法的一个特例。根据 SICP 提供的内容，我把它理解为:</p>\n<blockquote>\n<p>如果 g(x) 可微分，且 f(x) = x - g(x) / Dg(x), 那么 g(x) = 0 的解即为 f(x) 的不动点。</p>\n</blockquote>\n<p>其中 <em>D</em> g(x) 表示 g(x) 的导函数。</p>\n<p>那么求 sqrt(x) 可以等价为求 g(y) = y^2 - x 的零点，又可等价为求 f(y) 的不动点，此时就又可以使用上一个方法中求不动点的函数。</p>\n<p>对于表示 <em>D</em> g(x) 可以参考导函数的定义: <em>D</em> g(x) = (g(x + dx) + g(x)) / dx。只要 dx 足够小，那么求出的值也会足够精确。因此可以写出讲 g(x) 转换为 f(x) 的代码:</p>\n<pre><code class=\"python\">def deriv(f):\n    return lambda x: (f(x + dx) - f(x)) / dx\n\ndef newton_transform(g):\n    return lambda x: x - g(x) / deriv(g)(x)\n</code></pre>\n<p>在此基础上修改 sqrt 函数即可（与上文重复的部分用 pass 代替):</p>\n<pre><code class=\"python\">def fixed_point(f, guess):\n    pass\n\ndef deriv(f):\n    dx = 0.00001\n    pass\n\ndef newton_transform(g):\n    pass\n\ndef sqrt(x):\n    return fixed_point(newton_transform(lambda y: x - y * y), 1.0)\n</code></pre>\n<h1 id=\"比较\">比较</h1><p>我随意选了一些数据做测试，其中括号中为 good_enough 的调用次数</p>\n<table>\n<thead>\n<tr>\n<th>测试数据</th>\n<th>牛顿法</th>\n<th>不动点</th>\n<th>牛顿法（进一步）</th>\n<th>math.sqrt</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>4e-10</td>\n<td>(14) 6.320421028899002e-05</td>\n<td>(14) 6.320421028899002e-05</td>\n<td>(14) 6.793792409042473e-05</td>\n<td>2e-5</td>\n</tr>\n<tr>\n<td>4e10</td>\n<td>(23) 200000.0</td>\n<td>(23) 200000.0</td>\n<td>(22) 200000.0</td>\n<td>200000.0</td>\n</tr>\n<tr>\n<td>17</td>\n<td>(6) 4.123105625617805</td>\n<td>(6) 4.123105625617805</td>\n<td>(6) 4.123105625619134</td>\n<td>4.123105625617661</td>\n</tr>\n<tr>\n<td>177</td>\n<td>(8) 13.30413469565007</td>\n<td>(8) 13.30413469565007</td>\n<td>(8) 13.304134695650115</td>\n<td>13.30413469565007</td>\n</tr>\n</tbody>\n</table>\n<p>可以发现：大体来说其实也差不了太多。其中，进一步的牛顿法受限于 dx 的精读不够，如果将 dx 调小至 0.0000001, 那么结果则与前两者差不多了。</p>\n<p>另外，求平方根的方法肯定不只这么几种，必然有更多方法。这些方法在一定程度上能拓展学习者的思路。<del>但一般情况下，大部分人还是直接调用标准库吧。</del></p>\n<h1 id=\"参考\">参考</h1><ol>\n<li><a href=\"https://book.douban.com/subject/1148282/\" target=\"_blank\" rel=\"external\">SICP</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8A%A8%E7%82%B9\" target=\"_blank\" rel=\"external\">Wikipedia 不动点</a></li>\n<li><a href=\"http://stackoverflow.com/questions/3860929/why-does-average-damping-magically-speed-up-the-convergence-of-fixed-point-calcu\" target=\"_blank\" rel=\"external\">Why does average damping magically speed up the convergence of fixed-point calculators?</a></li>\n</ol>\n","categories":[{"name":"Math","slug":"Math","path":"api/categories/Math.json"}],"tags":[{"name":"Math","slug":"Math","path":"api/tags/Math.json"},{"name":"Python","slug":"Python","path":"api/tags/Python.json"},{"name":"SICP","slug":"SICP","path":"api/tags/SICP.json"}]}