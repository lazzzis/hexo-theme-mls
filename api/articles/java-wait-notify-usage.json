{"title":"Java 中 wait 与 notify 的简单操作","slug":"java-wait-notify-usage","date":"2016-02-15T14:05:51.000Z","updated":"2016-11-08T11:23:41.000Z","comments":true,"path":"api/articles/java-wait-notify-usage.json","excerpt":"<p>在我知道wait() 与 notify() 以前，我常常用一种看似很 low 的方式控制线程同步</p>\n<pre><code class=\"java\">while(condition) {\n  return ;\n}\n</code></pre>\n<p>实际上这个线程是一直在运行的，并没有操作系统概念中的阻塞（Block）。而要实现阻塞（Block）则要借助 Java 线程中的 wait() 操作 与 notify() 操作。</p>\n<h1 id=\"相对简单的例子\">相对简单的例子</h1>","content":"<p>在我知道wait() 与 notify() 以前，我常常用一种看似很 low 的方式控制线程同步</p>\n<pre><code class=\"java\">while(condition) {\n  return ;\n}\n</code></pre>\n<p>实际上这个线程是一直在运行的，并没有操作系统概念中的阻塞（Block）。而要实现阻塞（Block）则要借助 Java 线程中的 wait() 操作 与 notify() 操作。</p>\n<h1 id=\"相对简单的例子\">相对简单的例子</h1><p>wait() 操作与 notify() 操作必须在临界区内进行。而 synchronized 需要一个对象用作锁，以区分各个不同的临界区。比如临界区 A 中进行了 wait() 操作，在也必须在临界区A 中进行 notify() 操作。</p>\n<p>现看一个例子：</p>\n<pre><code class=\"java\">public class Test {\n    public static void main(String[] args) {\n        TestThread testThread = new TestThread();\n        testThread.start();\n        synchronized (testThread) {\n            System.out.println(&quot;Before wait&quot;);\n            try {\n                testThread.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(&quot;All completed!&quot;);\n    }\n}\n\nclass TestThread extends Thread {\n    @Override\n    public void run() {\n        synchronized (this) {\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(&quot;notify() Completed&quot;);\n            notify();\n        }\n    }\n}\n</code></pre>\n<p>例子中用了两次 <code>synchronized</code> ，但两次对应的参数是相同的，所以这两块代码都属于同一个临界区。当执行 wait 操作时，程序进入阻塞状态，在进行 notify 操作前，不会进行下一步，即不会输出<code>All completed!</code>。当 sleep 完成，即过了 5 秒钟后，触发 notify() 操作，打印<code>notify() Completed</code>。此时程序从阻塞状态进入就绪状态，然后进入运行状态，输出<code>All completed!</code>。</p>\n<p><em>注意点</em>:</p>\n<ol>\n<li>切记 wait 操作和 notify 操作要在同一个临界区中进行。</li>\n<li>在执行 wait 操作时会抛出一个 InterruptedException 的异常，记得捕获。</li>\n</ol>\n<p>输出结果参考：</p>\n<pre><code class=\"java\">Before wait\nnotify() Completed\nAll completed!\n</code></pre>\n<h1 id=\"相对复杂的例子\">相对复杂的例子</h1><p>从上面一个例子看出，wait 和 notify 操作实现了进程同步，类似于播放器的暂停(wait)与继续(notify)。只有在 notify 的情况下才能继续 wait 之后的内容，可以保证一些临界值的准确性。</p>\n<p>在操作系统概念中，有一个典型的 <em>消费者与生产者</em> 的模型。在一块区域中，最多存放 5 个 unit 的物品，当区域中的物品少于 5 个时，生产者就会生产 1 个 unit 的物品放在区域内；当区域中的物品大于 0 个时，消费者就会从区域中取走 1 个 unit 的物品。</p>\n<p>如果用 wait 与 notify 模拟的话，那就是要控制好两者的出现时机。</p>\n<p>先看代码：</p>\n<pre><code class=\"java\">import java.util.Date;\nimport java.util.Vector;\n/**\n* Created by lazzzis on 2/9/16.\n*/\npublic class Test{\n    public static void main(String[] args) {\n        Producer producer = new Producer();\n        producer.start();\n        new Consumer(producer).start();\n        try {\n            Thread.sleep(80);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.exit(0);\n    }\n}\nclass Producer extends Thread {\n    static final int MAXQUEUE = 5;\n    private Vector messages = new Vector();\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                this.putMessage();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    private synchronized void putMessage() throws InterruptedException {\n        while (messages.size() == MAXQUEUE) {\n            System.out.println(&quot;I\\&#39;m waiting!&quot;);\n            wait();\n        }\n        messages.addElement(new Date().toString());\n        System.out.println(&quot;put message&quot;);\n        notify();\n    }\n    public synchronized String getMessage() throws InterruptedException {\n        notify();\n        while (messages.size() == 0) {\n            wait();\n        }\n        String message = (String) messages.firstElement();\n        messages.removeElement(message);\n        return message;\n    }\n}\nclass Consumer extends Thread {\n    Producer producer;\n    public Consumer(Producer p) {\n        producer = p;\n    }\n    @Override\n    public void run() {\n        try {\n            while (true) {\n                String message = producer.getMessage();\n                System.out.println(&quot;Got message: &quot; + message);\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p><em>注意点:</em></p>\n<ol>\n<li><code>synchronized</code>对于同一对象的不同方法，算作同样的临界区</li>\n<li>两个方法中 notify 和 wait 的顺序相反，如果相同，极有可能发生两者同时处于wait状态，而导致无法触发 notify 的情况。</li>\n<li>在 getMessage 中触发 notify 会使触发 wait 的 putMessage 继续运行，相当于一旦有物品被取走，就会通知生产者马上生产一个</li>\n<li>在 putMessage 中触发 notify 会使触发 wait 的 getMessage 继续运行，相当于一旦有物品被生产，就会通知消费者马上取走一个。</li>\n</ol>\n<h1 id=\"参考\">参考</h1><ol>\n<li><a href=\"http://www.programcreek.com/2009/02/notify-and-wait-example/\" target=\"_blank\" rel=\"external\">Java Thread: notify() and wait() examples</a></li>\n<li><a href=\"http://stackoverflow.com/questions/886722/how-to-use-wait-and-notify-in-java\" target=\"_blank\" rel=\"external\">How to use wait and notify in Java?</a></li>\n</ol>\n","categories":[],"tags":[{"name":"Java","slug":"Java","path":"api/tags/Java.json"},{"name":"Thread","slug":"Thread","path":"api/tags/Thread.json"}]}